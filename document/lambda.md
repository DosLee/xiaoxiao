## Lambda
> 介绍Lambda是什么, 写一个由浅到深的Demo

#### 函数式接口

函数式接口: 一个加上注解 @Functionallnterface的接口, 例如Comparator.
这样的接口只有一个抽象方法, 注解 @Functionallnterface是一个信息型的注解, 标示
是一个函数式的接口, 区别与普通接口.

需要注意的是,函数式接口中的默认方法, 因为他们已经有了默认实现方法, 所以他们不计入
抽象方法, 还有函数式接口所定义的抽象方法若是和顶级类Object定义的抽象方法一样, 
不计入函数式接口的抽象方法, 比如"int hashCode();"

为什么抽象方法不计入呢?

Java 语法规定，任何类都有一个默认的上级类，那就是顶级类 Object，
并对顶级 Object 的抽象方法做了默认实现. 在本例中，函数式接口的实现类也是一样，
它也默认继承了顶级类 Object ,并顶级类 Object 的抽象方法 hashCode 做了默认实现，
这相当于，对函数式接口中定义的 hashCode 也做了默认实现，函数式接口的实现类若是不想覆盖抽象
方法 hashCode ，保持默认实现，在 Java 语法上讲，完全没有问题. 

需要指出的是, 若是一个接口的定义符合函数式接口的定义, 即使没有加上注解, 编译器同样认为它是一个
函数式接口. 当然加上的话, 让人看到能一目了然

_**Lambda表达式是函数式接口的实现类的实例, 那么, 编写Lambda表达式, 实际上, 就是在编写函数式接口
唯一的抽象方法的实现.**_

#### Lambda表达式有如下特点

1. 调用方法时，它可以作为方法的参数,这个值可以是基础类型的值，也可以是一个类的实例.
因为Lambda是函数式接口实现类的的实例, 也是把类实例作为方法的参数.
2. 方法引用更加简洁和可读性更好.
3. 默认方法的功能允许你把新的默认方法添加到老旧的接口中，但依旧能够保持兼容性
4. 静态方法的功能允许你把新的静态方法添加到老旧的接口中，但依旧能够保持兼容性.
静态方法即是静态的默认方法. 在接口定义方法中，加上关键字 static. 既然静态方法也是默认方法，
为早期的接口添加静态方法的同时，不用去修改它的实现类，代码依旧可以不报错，保持兼容性.
5. Java8新添加了一些类和增强了一些类（修改原有的类，使之功能更加强大，很好的利用了Lambda表达式和Stream.

许多的方法，它的参数是接口类型的，当我们的程序调用这个方法时，需要为之传递一个实现了这个接口的实现类的实例. 
此处，我们假设有一个方法 F，它的参数是接口类型 I，为了调用这个方法 F，一种比较笨拙的方式是，定义一个类，假设为B，
类B实现接口I，创建类B的实例，拿着类B的实例作为方法F的参数. 显然，人们意识到了这种调用方法的笨拙，
于是，就出现了匿名的实现类. 我们知道，匿名的实现类，不需要独立创建接口的实现类，在给方法传递参数时即可直接实例化
一个匿名类的实例，同时，不需要指定接口实现类的类名（即称之为匿名. 这样的方式，显得更加的简洁和方便. 

#### 案例见代码


#### Lambda表达式语法
1. 参数部分
    1. 参数有类型, 有名字, 多个参数逗号分隔, 小括号括起来.
    2. 参数类型可以省略, JDK自动推断, 只有一个参数的时候小括号可以省略.
2. 箭头 ->
    1. 省略大部分{}, return关键字, 只留下表达式, 语法简洁
3. 方法体
    1. Lambda 表达式的方法体和普通函数的方法一样，使用花括号“{} ”括起来。花括号里面写 Java 语句。

#### 变量访问权限
1. Lambda 表达式本质是函数式接口的实现类实例，编写 Lambda 表达式，就是在编写函数式接口唯一抽象方法的是实现
















